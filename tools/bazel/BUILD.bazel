load(":rules.bzl", "my_rule")

exports_files(["bazel.md"])

# rule that runs shell script
sh_binary(
    name = "print_leetcode_problem",
    # shell script to run
    srcs = ["my_cat.sh"],
    # arguments to shell script
    # $location is to convert bazel label to a file system path
    args = ["$(location @leetcode_problem//:downloaded)"],
    # runtime data for the command
    data = ["@leetcode_problem//:downloaded"],
)

py_binary(
    name = "check_runfiles",
    srcs = ["check_runfiles.py"],
    # using check_runfiles_library won't work as it's testonly
    # srcs = [":check_runfiles_library"],
    data = [
        ":bazel.md",
        "//subpackage:file_in_subpackage.txt",
    ],
)

# when we call a rule we produce a target
# here it's a target named "my_rule_name_1"
my_rule(
    name = "my_rule_name_1",
    platform = select(
        {
            "@platforms//os:osx": "osx",
            "@platforms//os:linux": "linux",
        },
    ),
    username = "sasa",
)

config_setting(
    name = "macos_platform",
    # this setting "wins" in select() on osx
    constraint_values = ["@platforms//os:osx"],
)

config_setting(
    name = "linux_platform",
    # this setting "wins" in select() on linux
    constraint_values = ["@platforms//os:linux"],
)

config_setting(
    name = "x86_cpu",
    # this setting wins in select() when --cpu=x86 is passed on command line
    values = {
        "cpu": "x86",
    },
)

config_setting(
    name = "arm_cpu",
    # this setting wins in select() when --cpu=arm is passed on command line
    values = {
        "cpu": "arm",
    },
)

config_setting(
    name = "rock_paper",
    constraint_values = [
        ":rock",
        ":white",
    ],
)

# this is like enum definition for constraints, but with a terrible name constraint_setting
constraint_setting(name = "item_kind")

constraint_value(
    name = "rock",
    constraint_setting = "item_kind",
)

constraint_value(
    name = "paper",
    constraint_setting = "item_kind",
)

constraint_value(
    name = "scissors",
    constraint_setting = "item_kind",
)

constraint_setting(name = "item_color")

constraint_value(
    name = "white",
    constraint_setting = "item_color",
)

constraint_value(
    name = "black",
    constraint_setting = "item_color",
)

# platform is a terrible name for setting a bunch of constraint_values in one go
# when you pass --platforms=:rock_paper_scissors it will set these constraint_values
platform(
    name = "rock_paper_scissors",
    constraint_values = [
        ":rock",
        ":white",
        "@platforms//os:windows",
    ],
)

my_rule(
    name = "my_rule_name_2",
    platform = "whatever",
    username = "some name",
    # select can be used as right hand side of attribute assignment
    # here we pass different dependencies based on current platform
    # if there are two matches then results should be equal or one constraint
    # should be superset of another
    deps = select(
        {
            ":macos_platform": [
                ":bazel.md",
                ":hello.tp",
                ":my_rule_name_1",
            ],
            ":linux_platform": [":unknown_linux_platform_target"],
            ":x86_cpu": [":unknown_x86_cpu_target"],
            ":arm_cpu": [":unknown_arm_cpu_target"],
            # can be triggered with passing --platforms=//:rock_paper_scissors
            ":rock_paper": [":unknown_rock_paper"],
            # matches when nothing else matches
            "//conditions:default": [],
        },
        no_match_error = "Some error message if nothing matches",
    ),
)

py_test(
    name = "sandbox_test",
    # bazel styleguide says that source files should not start with `:`
    # so we don't write
    # srcs = [":test_sandbox.py"],
    # although it'll work
    srcs = ["test_sandbox.py"],
    main = "test_sandbox.py",
)

py_library(
    name = "check_runfiles_library",
    # testonly = True means that only testonly (e.g py_test) targets can use this library
    testonly = True,
    srcs = ["check_runfiles.py"],
)

genrule(
    name = "sandbox",
    outs = ["sandbox.txt"],
    # during the build time you can't write to filesystem outside the sandbox
    # see [test_sandbox.py] for an explanation of sandboxing
    cmd = "echo some_content > ~/tmp/some_file && echo done > $@",
)

print("BUILD file")
