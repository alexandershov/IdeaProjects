load(":rules.bzl", "my_rule")

exports_files(["bazel.md"])

# rule that runs shell script
sh_binary(
    name = "print_leetcode_problem",
    # shell script to run
    srcs = ["my_cat.sh"],
    # arguments to shell script
    # $location is to convert bazel label to a file system path
    args = ["$(location @leetcode_problem//:downloaded)"],
    # runtime data for the command
    data = ["@leetcode_problem//:downloaded"],
)

py_binary(
    name = "check_runfiles",
    srcs = ["check_runfiles.py"],
    # using check_runfiles_library won't work as it's testonly
    # srcs = [":check_runfiles_library"],
    data = [
        ":bazel.md",
        "//subpackage:file_in_subpackage.txt",
    ],
)

# when we call a rule we produce a target
# here it's a target named "my_rule_name_1"
my_rule(
    name = "my_rule_name_1",
    username = "sasa",
)

my_rule(
    name = "my_rule_name_2",
    username = "some name",
    deps = [
        ":bazel.md",
        ":my_rule_name_1",
    ],
)

py_test(
    name = "sandbox_test",
    # bazel styleguide says that source files should not start with `:`
    # so we don't write
    # srcs = [":test_sandbox.py"],
    # although it'll work
    srcs = ["test_sandbox.py"],
    main = "test_sandbox.py",
)

py_library(
    name = "check_runfiles_library",
    # testonly = True means that only testonly (e.g py_test) targets can use this library
    testonly = True,
    srcs = ["check_runfiles.py"],
)

genrule(
    name = "sandbox",
    outs = ["sandbox.txt"],
    # during the build time you can't write to filesystem outside the sandbox
    # see [test_sandbox.py] for an explanation of sandboxing
    cmd = "echo some_content > ~/tmp/some_file && echo done > $@",
)

print("BUILD file")
