## Bazel
Bazel is a language-agnostic build system. 

You write build rules in Starlark.

Starlark is basically a heavily restricted subset of Python.

Bazel allows you to describe dependencies and run rules only when rule inputs change.

Bazel uses cache to speed up build process. It caches downloaded files, rule ouputs etc.
Cache is implemented as Content Addressable Storage similar to git.

Install:
```shell
brew install bazelisk
```

Bazelisk is a wrapper around bazel, that can download the required version
of bazel and run it.

Run target:
```shell
bazel run :print_leetcode_problem
```

See .bzl and .bazel files for how `:print_leetcode_problem` target is defined.

## Query

Find all rule names recursively
```shell
bazel query //...
```

Find all rule names and file names (source and generated) recursively.
```shell
bazel query '//...:*'
```

In addition to rule names `*` also matches file names, but it doesn't consider subpackages.
More info is available using this command:
```shell
bazel help target-syntax
```

Find all dependencies of a target:
```shell
bazel query --notool_deps 'deps(:check_runfiles)'
```

Find all direct dependencies of a target, second argument of deps means depth
```shell
bazel query --notool_deps 'deps(:check_runfiles, 1)'
```


Find some dependency path between two targets
```shell
bazel query --notool_deps 'somepath(:check_runfiles, @bazel_tools//src/main/cpp/util:logging.cc)'
```

Find who depends on a target (aka "reversed dependencies")
```shell
bazel query --notool_deps 'rdeps(//..., check_runfiles.py)'
```

Find packages
```shell
bazel query '//...' --output=package
```

Find targets in newline-delimited json format
```shell
bazel query '//...' --output=streamed_jsonproto
```

Find targets with their source file location (file, lineno, column)
```shell
bazel query 'kind(rule, //...)' --output=location
```

Expand macros & globs
```shell
bazel query '//...' --output=build
```

Find rules
```shell
bazel query 'kind("rule", //...)'
```

Find kinds of rules (kind is e.g. py_binary/py_library)
```shell
bazel query 'kind(rule, //...)' --output=label_kind
```

Find targets generated by a macro `py_test`
```shell
bazel query 'attr(generator_function, py_test, //...)'
```

Find files generated by rules
```shell
bazel query 'kind("generated file", //...:*)'
```

Find medium tests
```shell
bazel query 'attr(size, "medium", tests(//...))'
```

Find all tests
```shell
bazel query 'tests(//...)'
```

Find all source files in dependencies of a target. This includes also files in `data`.
```shell
bazel query 'kind("source file", deps(//:check_runfiles))' --noimplicit_deps
```


```shell
bazel query 'kind("generated file", //...)'
```


Find differences between dependencies
```shell
bazel query --notool_deps 'deps(//...) except deps(//subpackage/...)'
```

Find common things between dependencies (`//:*` are all targets in root package)
```shell
bazel query --notool_deps 'deps(//:*) intersect deps(//subpackage/...)'
```

List all platforms
```shell
bazel query @platforms//os:all
```

## cquery

cquery can run after analysis phase (query runs after loading phase) and so it knows about 
output files

```shell
bazel cquery --output=files :my_rule_name_1
```

This doesn't work as we don't know output files after loading phase:
```shell
# doesn't work
bazel query --output=files :my_rule_name_1
```

Executable path in bazel-out, can be joined with workspace_root to get the absolute path
```shell
bazel cquery --output=starlark --starlark:expr='target.files_to_run.executable.path' //:check_runfiles
```

Executable path in runfiles
```shell
bazel cquery --output=starlark --starlark:expr='target.files_to_run.executable.short_path' //:check_runfiles
```

cquery can resolve results of `select`
```shell
bazel cquery 'deps(:my_rule_name_2, 1)' --noimplicit_deps
```

query can't resolve results of `select` and conservatively outputs all possibilities
```shell
bazel query 'deps(:my_rule_name_2, 1)' --noimplicit_deps
```

Setting user-defined platforms
```shell
bazel cquery 'deps(:my_rule_name_2, 1)' --noimplicit_deps --platforms=//:rock_paper_scissors
```

cquery outputs configuration id, it's essentially a hash of all build options.

View configuration (7170974 is short configuration id):
```shell
bazel config 7170974
```
Configuration is just a bunch of options.

## Coverage
See python.toolchain call in [MODULE.bazel](./MODULE.bazel) for coverage configuration for python.

Run coverage
```shell
 bazel coverage --combined_report=lcov //subpackage:passing_test
```

Coverage report will be available in bazel-out/_coverage/_coverage_report.dat

By default, test files are not instrumented for coverage, you can change that with
`--instrument_test_targets`
```shell
 bazel coverage --combined_report=lcov --instrument_test_targets //subpackage:passing_test
```

You can additionally specify which rules to instrument for coverage with
`--instrumentation_filter` which is a comma-separated list of target regexes
prefix regex with `-` to exclude mathing targets from instrumentation
```shell
 bazel coverage --combined_report=lcov --instrumentation_filter '//subpackage:b.*,-//subpackage:a.*' //subpackage:passing_test
```


## Directory structure
Bazel writes all of its data to a directory called `outputUserRoot`.
Its exact location differs across OSes.
On Linux it's `~/.cache/bazel/_bazel_${USER}`. On Mac it's `/private/var/tmp/_bazel_${USER}`
`outputUserRoot` contains:
* directories for each workspace (their names are md5 hashes of full paths to workspaces)
* `install/` directory containing installation of bazel

Bazel writes output of builds in workspace to `{outputUserRoot}/{md5(workspace)}/execroot/_main/bazel-out`.
For convenience bazel creates symlink to this directory in `{workspace}/bazel-out`.
`bazel info output_path` == `{outputUserRoot}/{md5(workspace)}/execroot/_main/bazel-out`
`bazel info output_base` == `{outputUserRoot}/{md5(workspace)}`
output_base also contains:
* `action_cache/` directory. So action cache is per-workspace.
* `external/` directory containing all fetched external repositories

`bazel clean` cleans `action_cache/` and output_path:

```shell
➜  bazel git:(main) ✗ ls $(bazel info output_base)/action_cache | wc -l
       2
➜  bazel git:(main) ✗ ls $(bazel info output_path) | wc -l
       4
➜  bazel git:(main) ✗ bazel clean
INFO: Starting clean (this may take a while). Consider using --async if the clean takes more than several minutes.
➜  bazel git:(main) ✗ ls $(bazel info output_base)/action_cache | wc -l
ls: /private/var/tmp/_bazel_aershov/aa113e5d9cb7e4bbe0353cfbd569ece8/action_cache: No such file or directory
       0
➜  bazel git:(main) ✗ ls $(bazel info output_path) | wc -l
ls: /private/var/tmp/_bazel_aershov/aa113e5d9cb7e4bbe0353cfbd569ece8/execroot/_main/bazel-out: No such file or directory
       0
```

`bazel clean --expunge` removes the whole output_base
```shell
➜  bazel git:(main) ✗ file $(bazel info output_base)
/private/var/tmp/_bazel_aershov/aa113e5d9cb7e4bbe0353cfbd569ece8: directory
➜  bazel git:(main) ✗ bazel clean --expunge
INFO: Starting clean (this may take a while). Consider using --async if the clean takes more than several minutes.
➜  bazel git:(main) ✗ ls /private/var/tmp/_bazel_aershov/aa113e5d9cb7e4bbe0353cfbd569ece8
ls: /private/var/tmp/_bazel_aershov/aa113e5d9cb7e4bbe0353cfbd569ece8: No such file or directory
```


## Caching

### Content Addressable Storage (CAS)
Bazel uses content-addressable storage (CAS) similar to git.
All source files are in CAS. All target outputs are in CAS.


### Action Cache (AC)
Bazel builds action graph. It has Action Cache (AC). 
AC key is hash of action inputs (input files, envvars, command being executed). 
AC value are hashes of outputs.
AC is located in `$(bazel info output_base)/action_cache
Action cache is represented as binary files in a filesystem.
We can explore it with 
```shell
bazel dump --action_cache
```
Since bazel expects all actions to be hermetic (i.e. each action should be a pure function from its inputs to its outputs), this
means that given inputs, bazel can look up if outputs are already in cache and skip actually
executing an action.

You can explore bazel action  graph with the `bazel aquery <...>`

### Repository Cache
There's also repository cache. when you use some repository_rule (e.g. http_archive), then
it uses `ctx.download` or `ctx.download_and_extract` which uses repository cache under the hood.
You pass sha256 to these repo_rules and bazel don't download anything if given sha256 is already in cache. 
Even if you pass the wrong url, then you'll still get the data from repository cache if there's an
entry in cache with the given sha256.

Repository cache is located at directory `bazel info repository_cache`.
It's also CAS and is shared across different workspaces.

Repository cache is not affected by bazel clean:

```shell
➜  bazel git:(main) ✗ ls $(bazel info repository_cache)/content_addressable/sha256  | wc -l
      31
➜  bazel git:(main) ✗ bazel clean --expunge
INFO: Starting clean (this may take a while). Consider using --async if the clean takes more than several minutes.
➜  bazel git:(main) ✗ ls $(bazel info repository_cache)/content_addressable/sha256  | wc -l
Starting local Bazel server and connecting to it...
      31
```

You can specify repository_cache directory with `--repository_cache` option:
```shell
bazel build :print_leetcode_problem --repository_cache ~/tmp/bazel_repo_cache
```

### In-memory Cache
There's also in-memory cache.
When you do `bazel <command>` it actually starts or uses already started bazel server.
It's written in Java and stores build-graph in memory.
You can shutdown bazel server with `bazel shutdown`.
On the next CLI invocation bazel server will be started again.
Bazel server can execute only one command at a time. That's why you're getting all
these "Another Bazel command is running" when trying two execute two bazel commands in parallel.


### Local/Remote Cache
Cache can be local or remote. Local cache is, ahem, local and lives on a local host machine.
Remote cache is, ahem, remote, essentially it's cache on some remote host.
Aside from that there is little differences between local and remote cache. Especially if you ignore tags = ["no-remote-cache"] 
which considers local cache as totally different from remote.

Local cache location is specified via --disk_cache parameter:
```shell
bazel test //subpackage:passing_test  --disk_cache=~/.cache/bazel
```

Disk cache stores actions, CAS of output files, and stdout/stderr of actions.
ATTENTION: this is a separate cache from AC and CAS. 
Disk cache can be shared by different workspaces. And disk cache is not garbage collected,
so you need a separate process of cleaning it up.

Passing disk_cache='' disables disk cache. It's actually default behaviour.

## Profiling

You can generate profile data with bazel, use `--profile=` flag.

```shell
bazel test --profile=subpackage_passing_test.json //subpackage:passing_test
```
This will generate profile data in Chrome Trace Event Format, you can visualize it
on https://ui.perfetto.dev