## Bazel
Bazel is a language-agnostic build system. 

You write build rules in Starlark.

Starlark is basically a heavily restricted subset of Python.

Bazel allows you to describe dependencies and run rules only when rule inputs change.

Bazel uses cache to speed up build process. It caches downloaded files, rule ouputs etc.
Cache is implemented as Content Addressable Storage similar to git.

Install:
```shell
brew install bazelisk
```

Bazelisk is a wrapper around bazel, that can download the required version
of bazel and run it.

Run target:
```shell
bazel run :print_leetcode_problem
```

See .bzl and .bazel files for how `:print_leetcode_problem` target is defined.

## Query

Find all dependencies of a target:
```shell
bazel query --notool_deps 'deps(:check_runfiles)'
```

Find all direct dependencies of a target, second argument of deps means depth
```shell
bazel query --notool_deps 'deps(:check_runfiles, 1)'
```


Find some dependency path between two targets
```shell
bazel query --notool_deps 'somepath(:check_runfiles, @bazel_tools//src/main/cpp/util:logging.cc)'
```

Find who depends on a target (aka "reversed dependencies")
```shell
bazel query --notool_deps 'rdeps(//..., check_runfiles.py)'
```

Find packages
```shell
bazel query '//...' --output=package
```

Find targets in newline-delimited json format
```shell
bazel query '//...' --output=streamed_jsonproto
```

Find targets with their source file location (file, lineno, column)
```shell
bazel query 'kind(rule, //...)' --output=location
```

Expand macros & globs
```shell
bazel query '//...' --output=build
```

Find rules
```shell
bazel query 'kind("rule", //...)'
```

Find kinds of rules (kind is e.g. py_binary/py_library)
```shell
bazel query 'kind(rule, //...)' --output=label_kind
```

Find targets generated by a macro `py_test`
```shell
bazel query 'attr(generator_function, py_test, //...)'
```

Find files generated by rules
```shell
bazel query 'kind("generated file", //...)'
```

Find medium tests
```shell
bazel query 'attr(size, "medium", tests(//...))'
```

Find all tests
```shell
bazel query 'tests(//...)'
```

Find all source files (for some reason it doesn't work)
```shell
bazel query 'kind("source file", //...)'
```

Find differences between dependencies
```shell
bazel query --notool_deps 'deps(//...) except deps(//subpackage/...)'
```

Find common things between dependencies (`//:*` are all targets in root package)
```shell
bazel query --notool_deps 'deps(//:*) intersect deps(//subpackage/...)'
```

List all platforms
```shell
bazel query @platforms//os:all
```

## cquery

cquery can run after analysis phase (query runs after loading phase) and so it knows about 
output files

```shell
bazel cquery --output=files :my_rule_name_1
```

This doesn't work as we don't know output files after loading phase:
```shell
# doesn't work
bazel query --output=files :my_rule_name_1
```

Executable path in bazel-out, can be joined with workspace_root to get the absolute path
```shell
bazel cquery --output=starlark --starlark:expr='target.files_to_run.executable.path' //:check_runfiles
```

Executable path in runfiles
```shell
bazel cquery --output=starlark --starlark:expr='target.files_to_run.executable.short_path' //:check_runfiles
```

cquery can resolve results of `select`
```shell
bazel cquery 'deps(:my_rule_name_2, 1)' --noimplicit_deps
```

query can't resolve results of `select` and conservatively outputs all possibilities
```shell
bazel query 'deps(:my_rule_name_2, 1)' --noimplicit_deps
```

Setting user-defined platforms
```shell
bazel cquery 'deps(:my_rule_name_2, 1)' --noimplicit_deps --platforms=//:rock_paper_scissors
```

cquery outputs configuration id, it's essentially a hash of all build options.

View configuration (7170974 is short configuration id):
```shell
bazel config 7170974
```
It's just a bunch of options.